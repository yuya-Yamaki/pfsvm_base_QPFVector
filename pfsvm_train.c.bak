#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "svm.h"
#include "pfsvm.h"
struct svm_parameter param;
struct svm_problem prob;
struct svm_model *model;
struct svm_node *x_space;

int main(int argc, char **argv)
{
    IMAGE *org, *dec;
    int cls[MAX_CLASS];
    int i, j, k, m, n, label;
    int num_class = 3;
    size_t elements;
    double th_list[MAX_CLASS/2], fvector[NUM_FEATURES], gain = 1.0;
    const char *error_msg;
    static int hevc_qp = 32;
    static double svm_c = 1.0, svm_gamma = 1.0 / NUM_FEATURES;
    static char *orgimg = NULL, *decimg = NULL, *modelfile = NULL;

    for (i = 1; i < argc; i++) {
	if (argv[i][0] == '-') {
	    switch (argv[i][1]) {
	    case 'Q':
		hevc_qp = atoi(argv[++i]);
		break;
	    case 'C':
		svm_c = atof(argv[++i]);
		break;
	    case 'G':
		svm_gamma = atof(argv[++i]);
		break;
	    case 'N':
		num_class = atof(argv[++i]);
		if (num_class < 3 || num_class > MAX_CLASS || (num_class % 2) == 0) {
		    fprintf(stderr, "# of classes is wrong!\n");
		    exit (1);
		}
		break;
	    default:
		fprintf(stderr, "Unknown option: %s!\n", argv[i]);
		exit (1);
	    }
	} else {
	    if (orgimg == NULL) {
		orgimg = argv[i];
	    } else if (decimg == NULL) {
		decimg = argv[i];
	    } else {
		modelfile = argv[i];
	    }
	}
    }
    if (modelfile == NULL) {
	printf("Usage: %s [options] original.pgm decoded.pgm model.svm\n",
	       argv[0]);
	printf("    -Q num  QP used in HEVC [%d]\n", hevc_qp);
	printf("    -C num  Penalty parameter for SVM [%f]\n", svm_c);
	printf("    -G num  Gamma parameter for SVM [%f]\n", svm_gamma);
	exit(0);
    }
    org = read_pgm(orgimg);
    dec = read_pgm(decimg);
    set_thresholds(org, dec, num_class, th_list);
    printf("PSNR = %.3f (dB)\n", calc_snr(org, dec));
    printf("# of classes = %d\n", num_class);
    printf("Thresholds = {%.1f", th_list[0]);
    for (k = 1; k < num_class / 2; k++) {
	printf(", %.1f", th_list[k]);
    }
    printf("}\n");
    printf("Gain factor = %f\n", gain);
    printf("SVM(gamma, C) = (%f,%f)\n", svm_gamma, svm_c);
    elements = 0;
    for (i = 0; i < dec->height; i++) {
	for (j = 0; j < dec->width; j++) {
	    elements += get_fvector(dec, i, j, gain, fvector);
	}
    }

    /* Setting for LIBSVM */
    param.svm_type = C_SVC;
    param.kernel_type = RBF;
    param.degree = 3;
    param.gamma = svm_gamma;
    param.coef0 = 0;
    param.nu = 0.5;
    param.cache_size = 100;
    param.C = svm_c;
    param.eps = 1e-3;
    param.p = 0.1;
    param.shrinking = 0; // Changed
    param.probability = 0;
    param.nr_weight = 0;
    param.weight_label = NULL;
    param.weight = NULL;
    prob.l = dec->width * dec->height;
    elements += prob.l;
    prob.y = Malloc(double, prob.l);
    prob.x = Malloc(struct svm_node *, prob.l);
    x_space = Malloc(struct svm_node, elements);
    for (k = 0; k < num_class; k++) cls[k] = 0;
    m = n = 0;
    for (i = 0; i < dec->height; i++) {
	for (j = 0; j < dec->width; j++) {
	    label = get_label(org, dec, i, j, num_class, th_list);
	    cls[label]++;
	    prob.y[m] = label;
	    prob.x[m] = &x_space[n];
	    get_fvector(dec, i, j, gain, fvector);
	    for (k = 0; k < NUM_FEATURES; k++) {
		if (fvector[k] != 0.0) {
		    x_space[n].index = k + 1;
		    x_space[n].value = fvector[k];
		    n++;
		}
	    }
	    x_space[n++].index = -1;
	    m++;
	}
    }
    for (k = 0; k < num_class; k++) {
	printf("CLASS[%d] = %d\n", k, cls[k]);
    }
    error_msg = svm_check_parameter(&prob,&param);
    if (error_msg) {
	fprintf(stderr,"ERROR: %s\n",error_msg);
	exit(1);
    }
    model = svm_train(&prob, &param);
    if (svm_save_model(modelfile, model)) {
	fprintf(stderr, "Can't save model to file %s\n", modelfile);
	exit(1);
    }
    svm_free_and_destroy_model(&model);
    svm_destroy_param(&param);
    free(prob.y);
    free(prob.x);
    free(x_space);
    return (0);
}
